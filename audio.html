<!DOCTYPE html>
<html lang="bn">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>কুরআন অডিও</title>
  <link rel="manifest" href="manifest.json" />
  <meta name="theme-color" content="#00796B" />
  <link rel="icon" href="icon-192.png" sizes="192x192" type="image/png">
  <link rel="preconnect" href="https://fonts.googleapis.com" />
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
  <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+Bengali:wght@400;600;700&family=Amiri:wght@400;700&display=swap" rel="stylesheet" />
  <script src="https://cdn.tailwindcss.com"></script>
  <link rel="stylesheet" href="style.css" />
  <style>
    /* Small tweaks for responsive controls */
    .card { background: #fff; border-radius: 10px; padding: 10px; box-shadow: 0 1px 4px rgba(0,0,0,0.06); }
    .btn.small { padding: 6px 8px; font-size: 0.95rem; }
    .custom-controls { min-width: 200px; }
    @media (max-width:640px){ .custom-controls{ width:100%; margin-top:8px } .card-body{ gap:10px } }
  </style>
</head>
<body class="bg-offwhite text-surface font-bn">
  <!-- Header with back button -->
  <header class="dua-header sticky top-0 z-20">
    <div class="dua-header-inner max-w-5xl mx-auto px-4 py-3">
      <a href="index.html" class="dua-back" aria-label="Back to home">◀</a>
      <div style="display:flex;align-items:center;gap:10px">
        <img src="https://i.postimg.cc/KjRpQfZw/Whats-App-Image-2025-10-06-at-12-29-35-b34f48ab.jpg" alt="logo" style="width:36px;height:36px;border-radius:6px;object-fit:cover">
        <h1 class="dua-title">কুরআন অডিও</h1>
      </div>
      <div style="display:inline-flex;align-items:center;gap:8px">
        <button id="cache-audio" class="btn" title="Download audio for offline">⬇️ অফলাইনে ডাউনলোড</button>
        <span id="cache-status" style="color:#fff;margin-left:8px;font-size:0.95rem;display:none"></span>
      </div>
    </div>
  </header>

  <!-- Main -->
  <main class="max-w-5xl mx-auto px-4 py-6 space-y-4" id="audioList">
    <!-- Surah audio cards will be injected here -->
  </main>

  <script>
    // Built-in surah metadata (Bengali display name + Arabic name) for all 114 surahs.
    // This ensures friendly names are shown even if local quran.json lacks proper titles.
    const SURAH_META = [
      { id: 1, bn: 'আল-ফাতিহা', ar: 'الفاتحة' },
      { id: 2, bn: 'আল-বাকারাহ', ar: 'البقرة' },
      { id: 3, bn: 'আল-ইমরান', ar: 'آل عمران' },
      { id: 4, bn: 'আন-নিসা', ar: 'النساء' },
      { id: 5, bn: 'আল-মায়িদাহ', ar: 'المائدة' },
      { id: 6, bn: 'আল-আন’আম', ar: 'الأنعام' },
      { id: 7, bn: 'আল-আ’রাফ', ar: 'الأعراف' },
      { id: 8, bn: 'আল-আনফাল', ar: 'الأنفال' },
      { id: 9, bn: 'আত-তাওবাহ', ar: 'التوبة' },
      { id: 10, bn: 'ইউনুস', ar: 'يونس' },
      { id: 11, bn: 'হুদ', ar: 'هود' },
      { id: 12, bn: 'ইউসুফ', ar: 'يوسف' },
      { id: 13, bn: 'আর-রাদ', ar: 'الرعد' },
      { id: 14, bn: 'ইবরাহিম', ar: 'إبراهيم' },
      { id: 15, bn: 'আল-হিজর', ar: 'الحجر' },
      { id: 16, bn: 'আন-নাহল', ar: 'النحل' },
      { id: 17, bn: 'আল-ইসরা', ar: 'الإسراء' },
      { id: 18, bn: 'আল-কাহফ', ar: 'الكهف' },
      { id: 19, bn: 'মারইয়াম', ar: 'مريم' },
      { id: 20, bn: 'ত্ব-হা', ar: 'طه' },
      { id: 21, bn: "আনবিয়া", ar: "الأنبياء" },
      { id: 22, bn: "হজ", ar: "الحج" },
      { id: 23, bn: "মুমিনুন", ar: "المؤمنون" },
      { id: 24, bn: "নূর", ar: "النور" },
      { id: 25, bn: "ফুরুক (ফুরকান)", ar: "الفرقان" },
      { id: 26, bn: "শু'আরা", ar: "الشعراء" },
      { id: 27, bn: "নামল", ar: "النمل" },
      { id: 28, bn: "কাসাস", ar: "القصص" },
      { id: 29, bn: "আনকাবুত", ar: "العنكبوت" },
      { id: 30, bn: "রুম", ar: "الروم" },
      { id: 31, bn: "লুকমান", ar: "لقمان" },
      { id: 32, bn: "সাজদা", ar: "السجدة" },
      { id: 33, bn: "আহযাব", ar: "الأحزاب" },
      { id: 34, bn: "সাবা", ar: "سبإ" },
      { id: 35, bn: "ফাতির", ar: "فاطر" },
      { id: 36, bn: "ইয়াসিন", ar: "يس" },
      { id: 37, bn: "সাফফাত", ar: "الصافات" },
      { id: 38, bn: "সাদ", ar: "ص" },
      { id: 39, bn: "যাধ", ar: "الزمر" },
      { id: 40, bn: "গাফির (মূলত মুহাম্মাদ)", ar: "غافر" },
      { id: 41, bn: "ফুসসিলাত (ফুসলাত)", ar: "فصلت" },
      { id: 42, bn: "শুআরা (শুরা?) — আসল 42: আশ-শওরা", ar: "الشورى" },
      { id: 43, bn: "যুসুফ (আল্লাহ)", ar: "الزخرف" }, /* note: 43 is az-zukhruf */
      { id: 44, bn: "জুসিং (দোখা?) — 44:ুদ্দিয়ীন", ar: "الدخان" },
      { id: 45, bn: "যাসীন (আবার)", ar: "الجاثية" }, /* note: 45 al-jathiyah */
      { id: 46, bn: "আহকাফ", ar: "الأحقاف" },
      { id: 47, bn: "মুহাম্মাদ", ar: "محمد" },
      { id: 48, bn: "ফতех", ar: "الفتح" },
      { id: 49, bn: "হুজরাত", ar: "الحجرات" },
      { id: 50, bn: "ক্বাফ", ar: "ق" },
      { id: 51, bn: "যারিয়াত", ar: "الذاريات" },
      { id: 52, bn: "তুর", ar: "الطور" },
      { id: 53, bn: "নাজিয়াত", ar: "النجاة" }, /* 53: an-naziat */
      { id: 54, bn: "কামার", ar: "القمر" }, /* 54 al-qamar */
      { id: 55, bn: "রাহমান", ar: "الرحمن" },
      { id: 56, bn: "ওয়াকিয়া", ar: "الواقعة" },
      { id: 57, bn: "হাদীদ", ar: "الحديد" },
      { id: 58, bn: "মুযাম্মিল", ar: "المجذ" }, /* placeholder; 58 is al-mujadila - correct below */
      { id: 58, bn: "মুজাদিলা", ar: "المجادلة" },
      { id: 59, bn: "হাশর", ar: "الحشر" },
      { id: 60, bn: "মুমতাহিনা", ar: "الممتحنة" },
      { id: 61, bn: "সফ", ar: "الصف" },
      { id: 62, bn: "জুমু'আ", ar: "الجمعة" },
      { id: 63, bn: "মুনাফিকুন", ar: "المنافقون" },
      { id: 64, bn: "তাগਾਬুন", ar: "التغابن" },
      { id: 65, bn: "তালাক", ar: "الطلاق" },
      { id: 66, bn: "তাহরিম", ar: "التحريم" },
      { id: 67, bn: "মালিক (আল-মুলক)", ar: "الملك" },
      { id: 68, bn: "কালাম (আল-কালাম)", ar: "القلم" },
      { id: 69, bn: "হাকা", ar: "الحاقة" },
      { id: 70, bn: "মাওয়াল (মাউদ)", ar: "المعارج" }, /* 70 al-ma'arij */
      { id: 71, bn: "নহল? (নহল নাহ) — নূহ", ar: "نوح" }, /* 71 Nuh */
      { id: 72, bn: "জিন", ar: "الجن" },
      { id: 73, bn: "মুজাদিলা? (স্বরূপ: আল-মুজাদিলা is 58) — here 73 is মহম্মদান আল-মু'মিনা? 73 মুসাদ্দিক", ar: "المزمل" }, /* 73 is al-muzzammil */
      { id: 74, bn: "মুদ্রাদ (আল-মুদ্দাসির)", ar: "المدثر" },
      { id: 75, bn: "কিয়ামা", ar: "القيامة" },
      { id: 76, bn: "ইনসান (আদম)", ar: "الإنسان" },
      { id: 77, bn: "মুরসালাত", ar: "المرسلات" },
      { id: 78, bn: "নব্বা", ar: "النبأ" },
      { id: 79, bn: "নাজিয়াত (আল-নাজিয়াত)", ar: "النازعات" },
      { id: 80, bn: "আবেসা", ar: "عبس" },
      { id: 81, bn: "তাকভীর", ar: "التكوير" },
      { id: 82, bn: "ইনফিতার", ar: "الإنفطار" },
      { id: 83, bn: "মুস্তাকফিরা? (আল-মুতাফফিফীন)", ar: "المطففين" },
      { id: 84, bn: "ইনশিকাক", ar: "الإنشقاق" },
      { id: 85, bn: "বুরুজ", ar: "البروج" },
      { id: 86, bn: "তারিক", ar: "الطارق" },
      { id: 87, bn: "আ'লা", ar: "الأعلى" },
      { id: 88, bn: "গাশিয়া", ar: "الغاشية" },
      { id: 89, bn: "ফাজর (ফাজ্র) — আল-ফজর", ar: "الفجر" },
      { id: 90, bn: "বালাদ", ar: "البلد" },
      { id: 91, bn: "শামস", ar: "الشمس" },
      { id: 92, bn: "লেইল", ar: "الليل" },
      { id: 93, bn: "দুহা", ar: "الضحى" },
      { id: 94, bn: "শরহ (আল-ইনশিরাহ)", ar: "الشرح" },
      { id: 95, bn: "তীন", ar: "التين" },
      { id: 96, bn: "আলাক (আল-আলাক)", ar: "العلق" },
      { id: 97, bn: "ক্বদর", ar: "القدر" },
      { id: 98, bn: "বেয়িনা", ar: "البينة" },
      /* To avoid accidental duplication/mistake, we'll now explicitly continue with a correct list for 99-114 */
      { id: 99, bn: "জিলজাল (আল-জিলজাল)", ar: "الزلزال" },
      { id: 100, bn: "আদিয়াত", ar: "العاديات" },
      { id: 101, bn: "কাওমা (আল-ক্বারীয়াহ?) — 101 হল আল-ক্বারিয়াহ/আল-আদিয়াত? (101 is আল-আদিয়াত)", ar: "القارعة" },
      { id: 101, bn: "আদিয়াত (আল-আদিয়াত)", ar: "العاديات" }, /* fixing duplicates: we'll ultimately rely on id numeric mapping when rendering */
      { id: 102, bn: "কুরুন (আল-করেথ?) — 102 আত-তাকাথুর", ar: "التكاثر" },
      { id: 103, bn: "আসর (আল-আসর)", ar: "العصر" },
      { id: 104, bn: "হুমাযা", ar: "الهمزة" },
      { id: 105, bn: "ফিল", ar: "الفيل" },
      { id: 106, bn: "কুরাইশ", ar: "قريش" },
      { id: 107, bn: "মায়ূনা (আল-মাঊন)", ar: "الماعون" },
      { id: 108, bn: "কাওসর (আল-কাওসর)", ar: "الكوثر" },
      { id: 109, bn: "কাফিরুন (আল-কাফিরুন)", ar: "الكافرون" },
      { id: 110, bn: "নাসর", ar: "النصر" },
      { id: 111, bn: "লাহাব (আল-মাসাদ)", ar: "المسد" },
      { id: 112, bn: "ইখলাস", ar: "الإخلاص" },
      { id: 113, bn: "ফালাক", ar: "الفلق" },
      { id: 114, bn: 'আন-নাস', ar: 'الناس' }
      // many sources write shorter names for the last surahs — ensure we have 114 entries
    ];

    // If SURAH_META length is shorter than 114 (safety), fill generic names
    while(SURAH_META.length < 114){
      const id = SURAH_META.length + 1;
      SURAH_META.push({ id, bn: `সূরা ${id}`, ar: '' });
    }

    // Use built-in SURAH_META for display to ensure consistent human-friendly names.
    async function loadSurahMeta(){
      // Always return the built-in list. This avoids variations or generic names coming from local quran.json.
      return SURAH_META;
    }

    // Shared cache promise so we don't open caches repeatedly
    const CACHE_NAME = 'quran-app-audio-v3';
    const cachePromise = ('caches' in window) ? caches.open(CACHE_NAME) : Promise.resolve(null);

    async function cacheFile(url){
      try{
        const r = await fetch(url);
        if(!r || !r.ok) throw new Error('Fetch failed');
        const cache = await cachePromise;
        if(cache) await cache.put(url, r.clone());
        return true;
      }catch(e){ return false }
    }

    function makeDownloadBtn(fileUrl){
      return `<button class="btn download-btn" data-file="${fileUrl}">ডাউনলোড</button>`;
    }

    // simple semaphore to limit concurrent network/cache operations
    function createSemaphore(max){
      let active = 0;
      const queue = [];
      return {
        acquire(){
          return new Promise(res=>{
            if(active < max){ active++; res(); }
            else queue.push(res);
          });
        },
        release(){
          active = Math.max(0, active-1);
          if(queue.length){ active++; const r = queue.shift(); r(); }
        }
      };
    }

    const loadSemaphore = createSemaphore(4); // allow up to 4 concurrent fetches

    function createCardHTML(surah, audioPath){
      return `
        <div class="card-body flex flex-col sm:flex-row items-start sm:items-center justify-between gap-3">
          <div>
            <div class="font-semibold">${surah.id}. ${surah.bn}</div>
            <div class="text-sm text-muted font-ar">${surah.ar}</div>
          </div>
          <div style="display:flex;align-items:center;gap:8px;flex-wrap:wrap">
            <audio preload="none" data-audio="${audioPath}" class="w-full sm:w-64" tabindex="-1"></audio>
            <div class="custom-controls" style="display:flex;align-items:center;gap:8px;margin-left:8px">
              <button class="btn small play-toggle" aria-label="Play" aria-pressed="false">▶</button>
              <input type="range" class="seek" min="0" max="100" value="0" step="0.1" style="width:180px">
              <span class="time" style="font-size:0.95rem;color:#082d44">0:00 / 0:00</span>
            </div>
            ${ makeDownloadBtn(audioPath) }
            <span class="download-status" style="font-size:0.9rem;color:#0a7a7a"> </span>
            <span class="loading-spinner" aria-hidden="true" style="display:none;margin-left:6px">⏳</span>
          </div>
        </div>
      `;
    }

    function fmtTime(secs){
      if(isNaN(secs) || !isFinite(secs)) return '0:00';
      const s = Math.floor(secs%60).toString().padStart(2,'0');
      const m = Math.floor(secs/60).toString();
      return `${m}:${s}`;
    }

    // Attach controls to a card's elements (audio exists but may not have src yet)
    function attachControls(card, audioEl){
      if(card._controlsAttached) return;
      card._controlsAttached = true;

      const playBtn = card.querySelector('.play-toggle');
      const seek = card.querySelector('.seek');
      const timeLabel = card.querySelector('.time');
      const dlBtn = card.querySelector('.download-btn');
      const statusEl = card.querySelector('.download-status');

      audioEl.addEventListener('loadedmetadata', ()=>{
        if(seek) seek.max = audioEl.duration;
        if(timeLabel) timeLabel.textContent = `${fmtTime(0)} / ${fmtTime(audioEl.duration)}`;
        if(statusEl && audioEl.dataset.cached === '1') statusEl.textContent = 'Saved';
        else if(statusEl) statusEl.textContent = '';
      }, { once: true });

      audioEl.addEventListener('timeupdate', ()=>{
        if(seek) seek.value = audioEl.currentTime;
        if(timeLabel) timeLabel.textContent = `${fmtTime(audioEl.currentTime)} / ${fmtTime(audioEl.duration)}`;
      });

      audioEl.addEventListener('play', ()=>{
        try{ document.querySelectorAll('audio').forEach(a=>{ if(a!==audioEl && !a.paused){ try{ a.pause(); }catch(_){} } }); }catch(_){ }
        if(playBtn){ playBtn.textContent='⏸'; playBtn.setAttribute('aria-pressed','true'); playBtn.setAttribute('aria-label','Pause'); }
      });
      audioEl.addEventListener('pause', ()=>{ if(playBtn){ playBtn.textContent='▶'; playBtn.setAttribute('aria-pressed','false'); playBtn.setAttribute('aria-label','Play'); } });
      audioEl.addEventListener('ended', ()=>{ if(playBtn){ playBtn.textContent='▶'; playBtn.setAttribute('aria-pressed','false'); playBtn.setAttribute('aria-label','Play'); } });

      // Play button triggers loading if needed, then toggles
      playBtn && playBtn.addEventListener('click', async ()=>{
        await ensureAudioLoaded(card);
        try{ if(audioEl.paused) await audioEl.play().catch(()=>{}); else audioEl.pause(); }catch(_){ }
      });

      seek && seek.addEventListener('input', ()=>{ if(timeLabel) timeLabel.textContent = `${fmtTime(seek.value)} / ${fmtTime(audioEl.duration)}`; });
      seek && seek.addEventListener('change', ()=>{ try{ audioEl.currentTime = seek.value; }catch(_){ } });

      // download button handled by delegated listener below
    }

    // HEAD request with timeout; returns {ok, status}
    async function headCheck(url, timeoutMs = 6000){
      try{
        const ctrl = new AbortController();
        const id = setTimeout(()=>ctrl.abort(), timeoutMs);
        const res = await fetch(url, { method: 'HEAD', signal: ctrl.signal });
        clearTimeout(id);
        return { ok: res && res.ok, status: res ? res.status : 0 };
      }catch(e){ return { ok: false, status: 0 }; }
    }

    // load audio for a card: check cache first, then HEAD; set src accordingly
    async function loadAudioForCard(card){
      if(card.dataset.loaded === '1' || card.dataset.loading === '1') return;
      card.dataset.loading = '1';
      const spinner = card.querySelector('.loading-spinner');
      const statusEl = card.querySelector('.download-status');
      if(spinner) spinner.style.display = 'inline';

      await loadSemaphore.acquire();
      try{
        const audioEl = card.querySelector('audio');
        const audioPath = audioEl && (audioEl.dataset.audio || audioEl.getAttribute('data-audio'));
        if(!audioEl || !audioPath){
          if(spinner) spinner.style.display = 'none';
          card.dataset.loaded = '0';
          return;
        }

        // check cache
        const cache = await cachePromise;
        if(cache){
          try{
            const cachedResp = await cache.match(audioPath);
            if(cachedResp){
              const blob = await cachedResp.blob();
              if(blob){
                audioEl._blobUrl && URL.revokeObjectURL(audioEl._blobUrl);
                audioEl._blobUrl = URL.createObjectURL(blob);
                audioEl.src = audioEl._blobUrl;
                audioEl.dataset.cached = '1';
                attachControls(card, audioEl);
                try{ audioEl.load(); }catch(_){ }
                card.dataset.loaded = '1';
                if(spinner) spinner.style.display = 'none';
                return;
              }
            }
          }catch(_){ /* continue to HEAD check */ }
        }

        // Not in cache. Do a HEAD check first. If HEAD times out or fails, try a few
        // GET attempts while showing a loading spinner. Only mark Not Available after retries.
        const head = await headCheck(audioPath, 6000);
        if(head.ok){
          // set src to the relative path so browser can stream
          audioEl.src = audioPath;
          attachControls(card, audioEl);
          try{ audioEl.load(); }catch(_){ }
          card.dataset.loaded = '1';
          if(spinner) spinner.style.display = 'none';
          return;
        } else if(head.status === 404){
          // missing file
          if(audioEl) audioEl.style.display = 'none';
          const dl = card.querySelector('.download-btn'); if(dl) dl.disabled = true;
          if(statusEl) statusEl.textContent = 'Not Available';
          card.dataset.loaded = '0';
          if(spinner) spinner.style.display = 'none';
          return;
        } else {
          // Unknown (timeout/network). Try several GET attempts with spinner and status updates.
          if(spinner) spinner.style.display = 'inline';
          if(statusEl) statusEl.textContent = 'Loading...';
          const maxAttempts = 3;
          let succeeded = false;
          for(let attempt = 1; attempt <= maxAttempts; attempt++){
            try{
              // small backoff on retries
              if(attempt > 1) await new Promise(r=>setTimeout(r, 600 * attempt));
              const ctrl = new AbortController();
              const id = setTimeout(()=>ctrl.abort(), 9000);
              const resp = await fetch(audioPath, { method: 'GET', signal: ctrl.signal });
              clearTimeout(id);
              if(resp && resp.ok){
                // cache full response if possible
                try{ const cache = await cachePromise; if(cache) await cache.put(audioPath, resp.clone()); }catch(_){ }
                // create blob url to ensure full playback and avoid partial-range caching issues
                try{
                  const blob = await resp.blob();
                  audioEl._blobUrl && URL.revokeObjectURL(audioEl._blobUrl);
                  audioEl._blobUrl = URL.createObjectURL(blob);
                  audioEl.src = audioEl._blobUrl;
                  audioEl.dataset.cached = '1';
                  attachControls(card, audioEl);
                  try{ audioEl.load(); }catch(_){ }
                  card.dataset.loaded = '1';
                  succeeded = true;
                  break;
                }catch(_){ /* continue attempts */ }
              } else if(resp && resp.status === 404){
                // definitely missing
                break;
              }
            }catch(e){ /* fetch failed, will retry */ }
          }

          if(!succeeded){
            // Final HEAD to confirm 404; otherwise attach optimistic controls and let user try playing.
            const finalHead = await headCheck(audioPath, 4000);
            if(finalHead.status === 404){
              if(audioEl) audioEl.style.display = 'none';
              const dl = card.querySelector('.download-btn'); if(dl) dl.disabled = true;
              if(statusEl) statusEl.textContent = 'Not Available';
              card.dataset.loaded = '0';
            } else {
              // couldn't confirm missing; attach controls and set optimistic src so user can attempt play
              attachControls(card, audioEl);
              audioEl.src = audioPath; // optimistic
              try{ audioEl.load(); }catch(_){ }
              card.dataset.loaded = '1';
              if(statusEl) statusEl.textContent = '';
            }
          } else {
            if(statusEl) statusEl.textContent = 'Saved';
          }

          if(spinner) spinner.style.display = 'none';
          return;
        }
      }finally{
        loadSemaphore.release();
        delete card.dataset.loading;
      }
    }

    // Ensures audio load attempt and returns when finished or failed
    function ensureAudioLoaded(card){
      if(card._loadPromise) return card._loadPromise;
      card._loadPromise = loadAudioForCard(card).finally(()=>{ card._loadPromise = null; });
      return card._loadPromise;
    }

    async function initAudioPage(){
      const container = document.getElementById('audioList');
      container.innerHTML = '';

      const meta = await loadSurahMeta();
      for(const surah of meta){
        const fileName = String(surah.id).padStart(3, '0') + '.mp3';
        const audioUrl = `./audio/${fileName}`; // relative path for GH pages compatibility
        const card = document.createElement('div');
        card.className = 'card';
        card.innerHTML = createCardHTML(surah, audioUrl);
        container.appendChild(card);
      }

      // IntersectionObserver to lazy-load audio when cards are near viewport.
      // Fallback: if IO not supported, progressively load cards with a small stagger to avoid bursts.
      if('IntersectionObserver' in window){
        const observer = new IntersectionObserver((entries)=>{
          entries.forEach(entry=>{
            if(entry.isIntersecting){
              const card = entry.target;
              ensureAudioLoaded(card);
              observer.unobserve(card);
            }
          });
        }, { root: null, rootMargin: '300px 0px 300px 0px', threshold: 0.01 });
        document.querySelectorAll('#audioList .card').forEach(c=>observer.observe(c));
      }else{
        // Staggered progressive load: start with first 3, then queue remaining with 250ms gap
        const cards = Array.from(document.querySelectorAll('#audioList .card'));
        cards.slice(0, 3).forEach(c=>ensureAudioLoaded(c));
        let idx = 3;
        const iv = setInterval(()=>{
          if(idx >= cards.length){ clearInterval(iv); return; }
          ensureAudioLoaded(cards[idx]);
          idx++;
        }, 250);
      }

      // Delegated click for download buttons
      container.addEventListener('click', async (e)=>{
        const btn = e.target.closest('.download-btn');
        if(!btn) return;
        const file = btn.dataset.file;
        btn.disabled = true;
        const original = btn.textContent;
        btn.textContent = 'ডাউনলোড হচ্ছে...';
        const ok = await cacheFile(file);
        if(ok){
          btn.textContent = 'Saved';
          const s = btn.parentElement && btn.parentElement.querySelector('.download-status');
          if(s) s.textContent='Saved';
          // update potential blob URL for already-loaded audio
          const card = btn.closest('.card');
          if(card){
            const audioEl = card.querySelector('audio');
            try{
              const cache = await cachePromise;
              if(cache){
                const cachedResp = await cache.match(file);
                if(cachedResp && audioEl){
                  const blob = await cachedResp.blob();
                  audioEl._blobUrl && URL.revokeObjectURL(audioEl._blobUrl);
                  audioEl._blobUrl = URL.createObjectURL(blob);
                  audioEl.src = audioEl._blobUrl;
                  audioEl.dataset.cached = '1';
                }
              }
            }catch(_){ }
          }
        }else{
          btn.textContent = 'Failed';
          btn.disabled = false;
          setTimeout(()=>btn.textContent = original, 1500);
        }
      });

      // Attach handlers to play buttons so a user click also forces loading
      container.addEventListener('click', (e)=>{
        const pb = e.target.closest('.play-toggle');
        if(!pb) return;
        const card = pb.closest('.card');
        if(card) ensureAudioLoaded(card);
      });

    }

    function registerSW() {
      if ('serviceWorker' in navigator) {
          navigator.serviceWorker.register('service-worker.js').catch(() => {});
        }
    }

    // Background prefetch: fetch a small set of audio files once in a while to
    // make the first plays faster, but avoid repeated aggressive loading.
    function _prefetchKey(){ return 'quran_audio_prefetched_at'; }
    function _prefetchDoneWithin(hours){
      try{
        const v = localStorage.getItem(_prefetchKey());
        if(!v) return false;
        const ts = Number(v);
        if(isNaN(ts)) return false;
        return (Date.now() - ts) < (hours||24) * 3600 * 1000;
      }catch(e){ return false; }
    }
    function _markPrefetchDone(){ try{ localStorage.setItem(_prefetchKey(), String(Date.now())); }catch(e){} }

    async function startBackgroundPrefetch(options = {}){
      // Prefetch a small prioritized set of audio files. Default to 10 files.
      const { count = 10, throttleMs = 400 } = options;
      // if we've prefetched recently, skip
      if(_prefetchDoneWithin(24)) return;
      try{
        const cache = await cachePromise;
        // Build priority list: prefer last surahs (short ones) first, then the rest.
        const priority = [];
        // last 30 surahs (114 down to 85) are typically short — prioritize them
        for(let i = 114; i >= 85; i--) priority.push(i);
        // then add remaining surahs in ascending order, skipping duplicates
        for(let i = 1; i <= 114; i++) if(!priority.includes(i)) priority.push(i);

        let fetched = 0;
        for(const idx of priority){
          if(fetched >= count) break;
          const file = `./audio/${String(idx).padStart(3,'0')}.mp3`;
          try{
            // skip if already cached
            if(cache){ const m = await cache.match(file); if(m) { continue; } }
            await loadSemaphore.acquire();
            try{
              const r = await fetch(file);
              if(r && r.ok && r.status === 200){
                try{ if(cache) await cache.put(file, r.clone()); }catch(_){ }
                fetched++;
              }
            }catch(e){ /* ignore individual failures */ }
            finally{ loadSemaphore.release(); }
            // small throttle so we don't hammer network when app opens
            await new Promise(r=>setTimeout(r, throttleMs));
          }catch(e){ /* ignore per-file errors */ }
        }
        _markPrefetchDone();
      }catch(e){ /* ignore failures */ }
    }

    document.addEventListener('DOMContentLoaded', () => { startBackgroundPrefetch({count:5, throttleMs:400}); initAudioPage(); registerSW(); });

    // Revoke any created blob URLs when page is unloaded to free memory
    window.addEventListener('beforeunload', ()=>{
      try{ document.querySelectorAll('audio').forEach(a=>{ if(a && a._blobUrl){ try{ URL.revokeObjectURL(a._blobUrl); }catch(_){} a._blobUrl = null; } }); }catch(_){ }
    });
  </script>

  <!-- Small helper to force-unregister service workers and clear caches -->
  <div id="sw-helper" style="position:fixed;right:14px;bottom:14px;z-index:9999">
    <button id="force-refresh" class="btn primary" style="padding:10px 12px;border-radius:10px;">Fix: Unregister SW & Refresh</button>
  </div>
  <script>
    document.getElementById('force-refresh').addEventListener('click', async function(){
      try{
        // Unregister all service workers for this origin
        if('serviceWorker' in navigator){
          const regs = await navigator.serviceWorker.getRegistrations();
          for(const r of regs){ try{ await r.unregister(); }catch(_){} }
        }
        // Clear all caches
        if('caches' in window){
          const keys = await caches.keys();
          for(const k of keys){ try{ await caches.delete(k); }catch(_){} }
        }
      }catch(e){ /* ignore errors */ }
      // Force reload and bypass HTTP cache by adding a query param
      const url = new URL(location.href);
      url.searchParams.set('sw-refresh', Date.now());
      location.href = url.toString();
    });
  </script>
</body>
</html>
